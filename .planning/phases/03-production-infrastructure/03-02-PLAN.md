---
phase: 03-production-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/lib/storage.ts
  - server/src/routes/clients.ts
  - server/src/routes/exercises.ts
  - server/src/routes/progressPhotos.ts
  - server/src/index.ts
  - mobile/src/api.ts
  - mobile/app.json
autonomous: true

must_haves:
  truths:
    - "File uploads (client photos, exercise videos, progress photos) are stored in S3-compatible bucket storage, not the local filesystem"
    - "Uploaded files are served via a presigned-URL proxy endpoint at GET /api/files/*"
    - "Mobile app uses a configurable API URL that defaults to dev but can be set to production via app.json extra config"
    - "The UPLOADS_BASE pattern in mobile screens continues to work with the new proxy endpoint"
  artifacts:
    - path: "server/src/lib/storage.ts"
      provides: "S3 client with uploadFile and getSignedFileUrl helpers"
      contains: "S3Client"
    - path: "server/src/routes/clients.ts"
      provides: "Client photo upload via S3 instead of disk"
      contains: "memoryStorage"
    - path: "server/src/routes/exercises.ts"
      provides: "Exercise video upload via S3 instead of disk"
      contains: "memoryStorage"
    - path: "server/src/routes/progressPhotos.ts"
      provides: "Progress photo upload via S3 instead of disk"
      contains: "memoryStorage"
    - path: "server/src/index.ts"
      provides: "GET /api/files/* proxy endpoint for serving uploaded files"
      contains: "/api/files"
    - path: "mobile/src/api.ts"
      provides: "Production-aware API URL using Expo config"
      contains: "expoConfig"
    - path: "mobile/app.json"
      provides: "Extra config field for production API URL"
      contains: "apiUrl"
  key_links:
    - from: "server/src/routes/clients.ts"
      to: "server/src/lib/storage.ts"
      via: "import uploadFile"
      pattern: "uploadFile"
    - from: "server/src/routes/exercises.ts"
      to: "server/src/lib/storage.ts"
      via: "import uploadFile"
      pattern: "uploadFile"
    - from: "server/src/routes/progressPhotos.ts"
      to: "server/src/lib/storage.ts"
      via: "import uploadFile"
      pattern: "uploadFile"
    - from: "mobile/src/api.ts"
      to: "mobile/app.json"
      via: "Constants.expoConfig.extra.apiUrl"
      pattern: "expoConfig"
---

<objective>
Migrate file uploads from local disk storage to S3-compatible bucket storage and configure the mobile app for production API URL.

Purpose: Railway's filesystem is ephemeral -- files written to disk are lost on every deploy. All uploads must go to Railway's S3-compatible storage bucket. The mobile app also needs a way to point at the production API instead of hardcoded localhost.

Output: Three upload routes use S3 instead of disk, a proxy endpoint serves files via presigned URLs, and the mobile app reads its API URL from Expo config.
</objective>

<execution_context>
@/Users/dylanwagner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dylanwagner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-production-infrastructure/03-RESEARCH.md
@server/src/routes/clients.ts
@server/src/routes/exercises.ts
@server/src/routes/progressPhotos.ts
@server/src/index.ts
@mobile/src/api.ts
@mobile/app.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install S3 SDK, create storage lib, add files proxy endpoint</name>
  <files>server/package.json, server/src/lib/storage.ts, server/src/index.ts</files>
  <action>
1. Install S3 dependencies in server:
   ```
   cd server && npm install @aws-sdk/client-s3 @aws-sdk/s3-request-presigner
   ```

2. Create server/src/lib/storage.ts:
   ```typescript
   import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from "@aws-sdk/client-s3";
   import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

   // S3 client is only used when bucket env vars are set (production).
   // In development, uploads still go to disk via the existing multer diskStorage fallback.
   const s3 = process.env.BUCKET_ENDPOINT
     ? new S3Client({
         region: process.env.BUCKET_REGION || "us-east-1",
         endpoint: process.env.BUCKET_ENDPOINT,
         credentials: {
           accessKeyId: process.env.BUCKET_ACCESS_KEY_ID!,
           secretAccessKey: process.env.BUCKET_SECRET_ACCESS_KEY!,
         },
         forcePathStyle: true,
       })
     : null;

   const BUCKET = process.env.BUCKET_NAME || "";

   export function isS3Enabled(): boolean {
     return s3 !== null;
   }

   export async function uploadFile(key: string, body: Buffer, contentType: string): Promise<string> {
     if (!s3) throw new Error("S3 not configured");
     await s3.send(
       new PutObjectCommand({
         Bucket: BUCKET,
         Key: key,
         Body: body,
         ContentType: contentType,
       })
     );
     return key;
   }

   export async function getSignedFileUrl(key: string, expiresIn = 3600): Promise<string> {
     if (!s3) throw new Error("S3 not configured");
     const command = new GetObjectCommand({ Bucket: BUCKET, Key: key });
     return getSignedUrl(s3, command, { expiresIn });
   }

   export async function deleteFile(key: string): Promise<void> {
     if (!s3) throw new Error("S3 not configured");
     await s3.send(new DeleteObjectCommand({ Bucket: BUCKET, Key: key }));
   }
   ```
   The conditional S3 client means local dev continues to work without bucket env vars.

3. Add a files proxy endpoint to server/src/index.ts. Add BEFORE the existing route registrations (after express.json() and static middleware), add a new import and route:

   Add import at top:
   ```typescript
   import { isS3Enabled, getSignedFileUrl } from "./lib/storage.js";
   ```

   Add route after the health endpoint and before the auth route:
   ```typescript
   // File proxy -- serves uploaded files via S3 presigned URL redirect
   // In production: redirects to S3 presigned URL
   // In development: falls through to express.static("/uploads") above
   app.get("/api/files/:key(*)", requireAuth, async (req, res) => {
     if (!isS3Enabled()) {
       return res.status(404).json({ error: "S3 not configured" });
     }
     try {
       const key = (req.params as Record<string, string>).key;
       const url = await getSignedFileUrl(key);
       res.redirect(url);
     } catch (err) {
       console.error("File proxy error:", err);
       res.status(500).json({ error: "Failed to generate file URL" });
     }
   });
   ```

   Keep the existing `express.static("/uploads")` line -- it serves files in local dev. In production, files will be in S3 and served via the /api/files/ proxy.
  </action>
  <verify>
1. `cd server && npm run build` compiles without errors (storage.ts included).
2. `ls server/dist/lib/` shows storage.js exists.
3. Start dev server and confirm /api/health still works (no regressions from new imports).
  </verify>
  <done>S3 SDK installed, storage.ts provides uploadFile/getSignedFileUrl/deleteFile helpers, /api/files/* proxy endpoint registered in index.ts</done>
</task>

<task type="auto">
  <name>Task 2: Migrate 3 upload routes to S3 + update mobile API URL config</name>
  <files>server/src/routes/clients.ts, server/src/routes/exercises.ts, server/src/routes/progressPhotos.ts, mobile/src/api.ts, mobile/app.json</files>
  <action>
**For each of the 3 route files, apply the same pattern:**

The routes need to support BOTH local dev (multer diskStorage, no bucket vars) and production (multer memoryStorage, S3 upload). Use the `isS3Enabled()` check to branch.

**1. Update server/src/routes/clients.ts:**

Replace the existing multer setup and photo upload handler:

- Change multer storage to conditionally use memoryStorage or diskStorage:
  ```typescript
  import multer from "multer";
  import path from "path";
  import { fileURLToPath } from "url";
  import { isS3Enabled, uploadFile } from "../lib/storage.js";

  const __dirname = path.dirname(fileURLToPath(import.meta.url));

  const storage = isS3Enabled()
    ? multer.memoryStorage()
    : multer.diskStorage({
        destination: path.join(__dirname, "../../uploads"),
        filename: (_req, file, cb) => {
          const ext = path.extname(file.originalname);
          cb(null, `${Date.now()}${ext}`);
        },
      });
  const upload = multer({ storage, limits: { fileSize: 5 * 1024 * 1024 } });
  ```

- Update the POST /:id/photo handler:
  ```typescript
  router.post("/:id/photo", requireTrainer, upload.single("photo"), async (req, res) => {
    if (!req.file) return res.status(400).json({ error: "No file uploaded" });

    let photoUrl: string;
    if (isS3Enabled()) {
      const ext = path.extname(req.file.originalname);
      const key = `clients/${Date.now()}${ext}`;
      await uploadFile(key, req.file.buffer, req.file.mimetype);
      photoUrl = key; // Store S3 key in database
    } else {
      photoUrl = `/uploads/${req.file.filename}`; // Store local path
    }

    const { rows } = await pool.query(
      "UPDATE clients SET photo_url=$1, updated_at=NOW() WHERE id=$2 RETURNING *",
      [photoUrl, req.params.id]
    );
    if (!rows.length) return res.status(404).json({ error: "Not found" });
    res.json(rows[0]);
  });
  ```

- Remove the `crypto` import (it is only used by generateAccessCode which already has it). Keep all other routes unchanged.

**2. Update server/src/routes/exercises.ts:**

- Add import for storage: `import { isS3Enabled, uploadFile } from "../lib/storage.js";`
- Change multer storage to conditional (memoryStorage if S3, else diskStorage):
  ```typescript
  const videoStorage = isS3Enabled()
    ? multer.memoryStorage()
    : multer.diskStorage({
        destination: path.join(__dirname, "../../uploads/videos"),
        filename: (_req, file, cb) => {
          const ext = path.extname(file.originalname);
          cb(null, `${Date.now()}${ext}`);
        },
      });
  ```
- Update the POST /:id/video handler:
  ```typescript
  router.post("/:id/video", requireTrainer, videoUpload.single("video"), async (req, res) => {
    if (!req.file) return res.status(400).json({ error: "No video file uploaded" });

    let videoPath: string;
    if (isS3Enabled()) {
      const ext = path.extname(req.file.originalname);
      const key = `videos/${Date.now()}${ext}`;
      await uploadFile(key, req.file.buffer, req.file.mimetype);
      videoPath = key;
    } else {
      videoPath = `/uploads/videos/${req.file.filename}`;
    }

    const { rows } = await pool.query(
      "UPDATE exercises SET video_path=$1, updated_at=NOW() WHERE id=$2 RETURNING *",
      [videoPath, req.params.id]
    );
    if (!rows.length) return res.status(404).json({ error: "Not found" });
    res.json(rows[0]);
  });
  ```

**3. Update server/src/routes/progressPhotos.ts:**

- Add import for storage: `import { isS3Enabled, uploadFile } from "../lib/storage.js";`
- Change multer storage to conditional:
  ```typescript
  const photoStorage = isS3Enabled()
    ? multer.memoryStorage()
    : multer.diskStorage({
        destination: path.join(__dirname, "../../uploads/progress"),
        filename: (_req, file, cb) => {
          const ext = path.extname(file.originalname);
          cb(null, `${Date.now()}-${Math.random().toString(36).slice(2, 8)}${ext}`);
        },
      });
  ```
- Update the POST / handler:
  ```typescript
  router.post("/", requireTrainer, photoUpload.single("photo"), async (req, res) => {
    const { clientId } = req.params as unknown as P;
    if (!req.file) return res.status(400).json({ error: "No photo uploaded" });

    let photoUrl: string;
    if (isS3Enabled()) {
      const ext = path.extname(req.file.originalname);
      const key = `progress/${Date.now()}-${Math.random().toString(36).slice(2, 8)}${ext}`;
      await uploadFile(key, req.file.buffer, req.file.mimetype);
      photoUrl = key;
    } else {
      photoUrl = `/uploads/progress/${req.file.filename}`;
    }

    const { category, notes, taken_at } = req.body;
    const { rows } = await pool.query(
      `INSERT INTO progress_photos (client_id, photo_url, category, notes, taken_at)
       VALUES ($1,$2,$3,$4,$5) RETURNING *`,
      [clientId, photoUrl, category || "front", notes || null, taken_at || new Date().toISOString()]
    );
    res.status(201).json(rows[0]);
  });
  ```

**4. Update mobile/src/api.ts:**

Replace the hardcoded DEV_HOST pattern with Expo config-aware URL:

```typescript
import { Platform } from "react-native";
import Constants from "expo-constants";

// Production: reads from app.json > expo.extra.apiUrl
// Development: falls back to LAN IP for physical device testing
const DEV_HOST = "192.168.1.68";
const DEV_URL = Platform.OS === "android" ? "http://10.0.2.2:3000" : `http://${DEV_HOST}:3000`;

const API_URL = Constants.expoConfig?.extra?.apiUrl || DEV_URL;

const BASE = `${API_URL}/api`;
export const UPLOADS_BASE = API_URL;
```

Keep ALL other exports and functions (setToken, authHeaders, request, api object) exactly as they are. Only the URL construction at the top changes.

IMPORTANT: In production, UPLOADS_BASE will be the Railway URL (e.g., https://pt-tracker.up.railway.app). The mobile screens use `${UPLOADS_BASE}${photo_url}` -- in production, photo_url will be an S3 key like `clients/12345.jpg`. This means the mobile app will try to load `https://pt-tracker.up.railway.app/clients/12345.jpg` which does NOT work.

To fix this, the mobile screens that display uploaded files need to construct URLs differently in production. The simplest fix: make UPLOADS_BASE point to `/api/files/` in production so images load via the presigned URL proxy. Update UPLOADS_BASE:

```typescript
// For uploaded files: in production, route through the /api/files/ proxy
// In dev, uploaded files are served via express.static at /uploads/
export const UPLOADS_BASE = Constants.expoConfig?.extra?.apiUrl
  ? `${API_URL}/api/files/`  // Production: proxy to S3 presigned URLs
  : (Platform.OS === "android" ? "http://10.0.2.2:3000" : `http://${DEV_HOST}:3000`);
```

Wait -- this changes the URL pattern. Currently mobile uses `UPLOADS_BASE + photo_url` where photo_url = `/uploads/progress/file.jpg` (with leading slash). In production, photo_url will be `progress/file.jpg` (no leading slash, S3 key). The `/api/files/:key(*)` endpoint handles S3 keys.

But in dev, photo_url = `/uploads/progress/file.jpg` and UPLOADS_BASE = `http://192.168.1.68:3000`, so the full URL is `http://192.168.1.68:3000/uploads/progress/file.jpg` which express.static serves.

This is fine as-is -- the URL construction works for both dev and prod because:
- Dev: `http://host:3000` + `/uploads/progress/file.jpg` = works via express.static
- Prod: `https://app.up.railway.app` + `progress/file.jpg` = needs to go through `/api/files/progress/file.jpg`

For production to work, we need UPLOADS_BASE to include `/api/files/` when in production mode. But some screens use `${UPLOADS_BASE}/${photo_url}` (with an extra slash) and some use `${UPLOADS_BASE}${photo_url}` (no extra slash). Review the grep results:

- ClientDetailScreen: `${UPLOADS_BASE}/${client.photo_url}` -- extra slash
- ClientListScreen: `${UPLOADS_BASE}/${client.photo_url}` -- extra slash
- ClientFormScreen: `${UPLOADS_BASE}/${existingClient.photo_url}` -- extra slash
- All others: `${UPLOADS_BASE}${item.photo_url}` -- no extra slash

In dev, photo_url starts with `/uploads/...` so the extra slash creates `http://host:3000//uploads/...` which works fine (browsers normalize double slashes).

In production, photo_url will be `clients/12345.jpg` (no leading slash). So:
- UPLOADS_BASE should be `https://app.up.railway.app/api/files`
- Then `${UPLOADS_BASE}/${photo_url}` = `https://app.up.railway.app/api/files/clients/12345.jpg` -- correct
- And `${UPLOADS_BASE}${photo_url}` = `https://app.up.railway.app/api/filesprogress/12345.jpg` -- WRONG (missing slash)

Fix: set UPLOADS_BASE to `https://app.up.railway.app/api/files/` (trailing slash). Then:
- `${UPLOADS_BASE}/${photo_url}` = `.../api/files//clients/12345.jpg` -- works (double slash normalized)
- `${UPLOADS_BASE}${photo_url}` = `.../api/files/progress/12345.jpg` -- works

So the final UPLOADS_BASE export:
```typescript
export const UPLOADS_BASE = Constants.expoConfig?.extra?.apiUrl
  ? `${Constants.expoConfig.extra.apiUrl}/api/files/`
  : DEV_URL;
```

**5. Update mobile/app.json:**

Add `extra` field inside `expo`:
```json
{
  "expo": {
    ...existing fields...,
    "extra": {
      "apiUrl": ""
    }
  }
}
```
Leave apiUrl empty string for now (falsy = use dev fallback). Set to Railway URL after deployment in Plan 03.
  </action>
  <verify>
1. `cd server && npm run build` compiles without errors.
2. Start dev server: `cd server && TRAINER_PASSWORD=test123 JWT_SECRET=dev-secret npx tsx src/index.ts`
3. Verify existing upload endpoints still work in dev (S3 disabled, falls back to diskStorage):
   - Login: `curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"password":"test123"}'` -- get token
   - Health: `curl http://localhost:3000/api/health` -- returns ok
4. Verify /api/files/ returns 404 "S3 not configured" in dev (expected, no bucket vars).
5. `cd mobile && npx expo start` -- verify app still loads and connects to dev server (UPLOADS_BASE falls back to DEV_URL since no apiUrl in extra).
  </verify>
  <done>Three upload routes conditionally use S3 in production and disk in dev, /api/files/* proxy endpoint serves S3 files via presigned URLs, mobile api.ts reads API URL from Expo config with dev fallback, app.json has extra.apiUrl placeholder</done>
</task>

</tasks>

<verification>
1. `cd server && npm run build` compiles without errors (all new files included)
2. Dev server starts and serves /api/health, upload routes work with diskStorage (no S3 vars set)
3. /api/files/ endpoint returns 404 "S3 not configured" in dev
4. Mobile app connects to dev server (UPLOADS_BASE fallback works)
5. No existing functionality broken -- all dev workflows unchanged
</verification>

<success_criteria>
- storage.ts provides S3 upload/download/delete helpers with conditional initialization
- All 3 upload routes (clients, exercises, progressPhotos) use S3 when BUCKET_ENDPOINT is set, disk when not
- /api/files/* proxy endpoint generates presigned URL redirects for S3-stored files
- Mobile api.ts reads API URL from app.json extra.apiUrl, falls back to dev LAN IP
- app.json has extra.apiUrl field ready to be set to Railway URL
- Dev workflow fully preserved -- no S3 required for local development
</success_criteria>

<output>
After completion, create `.planning/phases/03-production-infrastructure/03-02-SUMMARY.md`
</output>
