---
phase: 03-production-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/tsconfig.json
  - server/package.json
  - server/src/instrument.ts
  - server/src/db.ts
  - server/src/index.ts
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Running `npm run build` in server/ compiles TypeScript to dist/ without errors"
    - "Running `npm run start` in server/ starts the server from compiled JS with Sentry loaded via --import"
    - "Sentry captures and reports unhandled errors thrown in Express route handlers"
    - "Database connection uses SSL when NODE_ENV=production"
    - "Migration SQL files are copied to dist/migrations/ during build"
  artifacts:
    - path: "server/src/instrument.ts"
      provides: "Sentry initialization loaded before all other modules"
      contains: "Sentry.init"
    - path: "server/src/index.ts"
      provides: "Sentry Express error handler registered after all routes"
      contains: "setupExpressErrorHandler"
    - path: "server/src/db.ts"
      provides: "SSL-aware database connection pool"
      contains: "ssl"
    - path: "server/package.json"
      provides: "build, start, and copy-migrations scripts"
      contains: "tsc"
    - path: "server/tsconfig.json"
      provides: "TypeScript build configuration with outDir and sourceMap"
      contains: "outDir"
  key_links:
    - from: "server/package.json"
      to: "server/tsconfig.json"
      via: "npm run build calls tsc"
      pattern: '"build".*tsc'
    - from: "server/package.json"
      to: "server/dist/instrument.mjs"
      via: "npm run start uses --import flag"
      pattern: '--import.*instrument'
    - from: "server/src/index.ts"
      to: "@sentry/node"
      via: "setupExpressErrorHandler after routes"
      pattern: "setupExpressErrorHandler"
---

<objective>
Configure the server for production builds with compiled TypeScript, Sentry error tracking, and SSL-aware database connections.

Purpose: The server currently runs via tsx (dev-only). Production on Railway requires compiled JS for Sentry's --import flag, proper SSL for Railway PostgreSQL, and error tracking so the trainer knows when things break.

Output: Server compiles to dist/, starts with Sentry instrumentation, connects to PostgreSQL with SSL in production, and reports errors to Sentry.
</objective>

<execution_context>
@/Users/dylanwagner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dylanwagner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-production-infrastructure/03-RESEARCH.md
@server/src/index.ts
@server/src/db.ts
@server/tsconfig.json
@server/package.json
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Sentry, configure tsconfig and package.json build scripts</name>
  <files>server/package.json, server/tsconfig.json, .gitignore</files>
  <action>
1. Install @sentry/node in server:
   ```
   cd server && npm install @sentry/node
   ```

2. Update server/tsconfig.json -- add sourceMap and declaration:false (keep existing fields):
   ```json
   {
     "compilerOptions": {
       "target": "ES2022",
       "module": "ES2022",
       "moduleResolution": "bundler",
       "esModuleInterop": true,
       "strict": true,
       "outDir": "dist",
       "rootDir": "src",
       "skipLibCheck": true,
       "declaration": false,
       "sourceMap": true
     },
     "include": ["src"]
   }
   ```

3. Update server/package.json scripts -- add build, start, copy-migrations, and prestart:
   ```json
   "scripts": {
     "dev": "tsx watch src/index.ts",
     "build": "tsc && npm run copy-migrations",
     "copy-migrations": "cp -r src/migrations dist/migrations",
     "start": "node --import ./dist/instrument.mjs dist/index.js",
     "migrate": "tsx src/migrate.ts",
     "seed": "tsx src/seed.ts"
   }
   ```
   The copy-migrations script copies .sql files to dist/ since tsc only compiles .ts files.
   The migrate and seed scripts still use tsx because they are run as one-off commands, not as the production server.

4. Add dist/ to the root .gitignore if not already present. The root .gitignore already has `dist/` so verify this covers server/dist/.
  </action>
  <verify>
Run `cd server && npm run build` -- should compile without errors and produce dist/ directory with .js and .js.map files. Verify dist/migrations/ contains all 12 .sql files. Verify dist/instrument.mjs exists (will be created in Task 2, but tsc output dir is confirmed here).
  </verify>
  <done>tsc compiles server/src to server/dist without errors, migration SQL files are copied to dist/migrations/, package.json has build/start/copy-migrations scripts</done>
</task>

<task type="auto">
  <name>Task 2: Create Sentry instrument file, add error handler to index.ts, add SSL to db.ts</name>
  <files>server/src/instrument.ts, server/src/index.ts, server/src/db.ts</files>
  <action>
1. Create server/src/instrument.ts:
   ```typescript
   import * as Sentry from "@sentry/node";

   Sentry.init({
     dsn: process.env.SENTRY_DSN,
     environment: process.env.NODE_ENV || "development",
     tracesSampleRate: 0.2,
     sendDefaultPii: false,
   });
   ```
   This file is loaded via --import flag before all other modules. If SENTRY_DSN is not set (local dev), Sentry silently disables itself.

2. Update server/src/index.ts:
   - Add `import * as Sentry from "@sentry/node";` at the top (after existing imports)
   - After ALL route registrations (after the messagesRouter line), add:
     ```typescript
     // Sentry error handler -- must be after all routes, before custom error handlers
     Sentry.setupExpressErrorHandler(app);

     // Fallback error handler
     app.use((err: Error, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
       console.error(err);
       res.status(500).json({ error: "Internal server error" });
     });
     ```
   - Keep everything else unchanged (health endpoint, route registrations, app.listen, startScheduler).

3. Update server/src/db.ts to add SSL for production:
   ```typescript
   import pg from "pg";

   const pool = new pg.Pool({
     connectionString:
       process.env.DATABASE_URL || "postgresql://localhost:5432/pt_tracker",
     ssl: process.env.NODE_ENV === "production" ? { rejectUnauthorized: false } : false,
   });

   export default pool;
   ```
   This enables SSL only in production (Railway PostgreSQL requires it). Local dev continues without SSL.
  </action>
  <verify>
1. Run `cd server && npm run build` -- compiles cleanly with instrument.ts included in output.
2. Verify dist/instrument.mjs (or dist/instrument.js depending on module output) exists.
3. Run the dev server briefly (`cd server && TRAINER_PASSWORD=test123 JWT_SECRET=dev-secret npx tsx src/index.ts`) and hit /api/health to confirm no regressions. Sentry will silently skip (no DSN set).
  </verify>
  <done>instrument.ts created with Sentry.init, index.ts has setupExpressErrorHandler after all routes, db.ts uses SSL when NODE_ENV=production, server builds and runs without errors</done>
</task>

</tasks>

<verification>
1. `cd server && npm run build` completes without errors
2. `ls server/dist/` shows compiled JS files including instrument.js and index.js
3. `ls server/dist/migrations/` shows all 12 .sql files
4. `cd server && TRAINER_PASSWORD=test123 JWT_SECRET=dev-secret npx tsx src/index.ts` starts without errors (dev mode, no Sentry DSN)
5. `curl http://localhost:3000/api/health` returns `{"status":"ok",...}`
</verification>

<success_criteria>
- Server compiles from TypeScript to JavaScript with `npm run build`
- Build output includes migration SQL files in dist/migrations/
- Sentry instrument file exists and will be loaded via --import in production
- Express error handler registered after all routes captures unhandled errors
- Database connection uses SSL when NODE_ENV=production, no SSL in development
- Dev workflow unchanged (tsx watch still works for local development)
</success_criteria>

<output>
After completion, create `.planning/phases/03-production-infrastructure/03-01-SUMMARY.md`
</output>
